# 	OPGS16 Debug Project

## 0. Abstract

* OPGS16 의 갖가지 기능들을 테스트하면서 부하가 없는가, 메모리 누수는 없는가를 확인한다.
* OPGS16 Debug Project 는 OPGS16 의 갖가지 기능을 테스트하면서도, 
  Win32, x64 에서 제대로 동작이 하는가를 확인해야 한다.
* OPGS16 Debug Project 는 여러 씬으로 나뉘고, 각각의 씬 (`Scene`) 은 각종 테스트를 수행한다.

`Feature Test` 의 목록들은 다음과 같으며 전부 다 구현해야 한다.

1. ~~`opgs16::random` 의 랜덤 테스트.~~ (완료)

   * `float` 랜덤 테스트.

     * `float` 을 화면에 `CText` 를 사용해서 보여준다.

   * `Integer` 랜덤 테스트

     * `int32_t` 값을 화면에 `CText` 을 사용해서 보여준다.

   * `PositiveInteger` 랜덤 테스트

     * $$ \text{value} >= 0 $$ 인 값을 화면에 `CText` 을 사용해서 보여준다.
       이 때 랜덤으로 나오는 값을 1,000,000 번 체크해서 음의 값이 나오면 테스트 실패로 간주한다.

     * $$ value < 0 $$ 인 값을 화면에 `CText` 을 사용해서 보여준다.

       이 때 랜덤으로 나오는 값을 1,000,000 번 체크해서 음의 값이 나오면 테스트 실패로 간주한다.

   * `DVector2 Unit length random Test` 랜덤 테스트

     * 여기서 찍혀진 점들의 $$ (x, y) $$ 정보를 임의 영역에 표시하게 할려면, 절차적 텍스쳐를 생성해서 텍스쳐를 바인딩해야 한다. 문제는 기존의 `Sprite2DRenderer` 는 절차적 텍스쳐를 생성해서 사용할 수가 없다. 따라서 `2D` 의 `Procedural` 한 `Texture` 을 만드는 `Renderer` 을 사용해야 한다.
       * 절차적 2D 텍스쳐를 생성해서 렌더링하는 렌더러 컴포넌트를 `Procedural2DRenderer` 라고 한다.

   * `DVector3 Unit length random test` 랜덤 테스트

     * 길이가 $$ 1 $$ 이 되는 임의 $$ (x, y, z) $$ 점을 가져와서 표시한다.

   * `DVector2 10 ~ 15 Random test` 랜덤 테스트

     * 길이가 $$ 10 $$ 에서 $$ 15 $$ 까지의 거리를 갖는 랜덤 벡터 $$ (x, y) $$ 을 가져와서 표시한다.

   * `DVector2 10 ~ 15 Random test` 랜덤 테스트

     * 길이가 $$ 10 $$ 에서 $$ 15 $$ 까지의 거리를 갖는 랜덤 벡터 $$ (x, y, z) $$ 을 가져와서 표시한다.

2. 오브젝트 부하 테스트 (완료?)

   * 기존에 있는걸 끌어다 쓴다.

   * `CCanvas` 위에 로그 오브젝트를 띄워서, 현재 어느 오브젝트가 생성이 되고, 생명 주기 함수가 불려졌는가를 확인한다. 
     * 로그로는 `SimpleLog` 을 사용한다.

   * 또 다른 방법으로는, 트리 형태로 되어있는 오브젝트에 대해 `SetActive` 함수를 테스트한다. 다음과 같이 `CObject` 트리가 짜여져 있다고 할 때, `Test 실장함`

3. 사운드 테스트

   * BGM 테스트를 한다. BGM 테스트를 해서 
     **1. 페이드 인으로 재생 2. 페이드 아웃으로 재생 3. 루프 4. 도중 일시 정지 후, 다시 재생 **
     **5. 음량 조절 6. 다른 BGM 과 변경하기 7. 다른 BGM 과 크로스 오버로 변경하기**

     가 있다.

   * Effect 테스트를 한다. Effect 테스트를 해서
     **1. 이펙트 재생 2. 이펙트 일시정지 후 다시 재생 3. 이펙트 정지 4. 다른 이펙트와 섞어 쓰기**

   * 서라운드 테스트를 한다. 오브젝트는 `SoundListener` 컴포넌트를 가지며, 다른 오브젝트는 `SoundEffect` 에 거리를 가지며 씬의 각 공간에 배치된다. 각 오브젝트는 각기 다른 음향 범위과 사운드를 가지고 있으며 겹치고, 멀어지면 소리가 들리지 않고, 가까이 가면 소리가 커지는 것을 실험한다.

4. 물리엔진 테스트

   * 2D 형태 플랫폼 점프 실시
   * 탑뷰 형태 RPG 류 게임의 지형지물 충돌 처리 테스트
   * 그 외 등등...
     * 구체적으로는 2D 형태의 플랫폼에, 경사면, 천장, 바닥, 낭떠러지, 그리고 올라갈 수 있는 오브젝트, 부부술 수 있는 오브젝트, 하단 점프 등을 구현할 것.
     * https://twitter.com/i/status/1016218478267727873

5. 3D 메쉬 테스트

   * 기본 3D 메쉬를 불러와서 스케일링, 회전, 이동 등의 처리 실시
   * 기본 3D 메쉬를 불러와서 빛 등의 쉐이더 및 복잡한 처리 테스트

6. 입력 테스트

   * 키보드 UI 를 만들어서 키를 입력하면 해당 키가 불이 들어올 수 있도록 함. 화면 사이즈가 `256x240` 이기 때문에 촘촘히 하던가 해야할 듯.
   * 키보드 테스트에서 `Stick key` 여부를 테스트한다. 또한 현재 바인딩 된 축을 대상으로 `Gravity` 테스트를 실시한다.
   * 마우스 UI 을 만들어서 마우스 인풋을 하면 해당 버튼이 불이 들어올 수 있도록 함.
   * 마우스 테스트에서, 화면에 보이는 물체를 클릭해서 물체가 제대로 좌표가 역변환되서 들어왔는가를 확인한다.

   1. `Keyboard Test`

      키보드를 테스트한다. 키 바인딩 설정에 상관없이 모든 값을 받아서 누르는 키에 대해서 불빛을 비추고, 현재 키에 대해서 Stick 일 때와 아닐 때를 로그로 보여준다.

      * 다만 `Numkey` 는 아직 지원하지 않기 때문에 나중에 한다.
      * 멀티 키 처리를 어떻게 하느냐가 문제인데... https://stackoverflow.com/questions/46631814/handling-multiple-keys-input-at-once-with-glfw 이것을 보면서 구조를 뜯어고쳐보면 어떨까 싶다.

7. 묘화 테스트

   * 일반 2D Sprite 기본 기능 (크기, 회전, 이동) 및 스프라이트 애니메이션 동작 기능.
     * 해야함.
   * 절차형 텍스쳐 렌더러 `Procedural2DRenderer` 기능 동작 확인 테스트.
     * 했음.
   * `Font2DRenderer` 및 `Font2DShaderRenderer` 테스트 동작 확인
     * 기존의 해당 테스트 파일을 연결시켜야 함.
   * 일반 2D Sprite 쉐이더 테스트 동작 확인
     * 해야함.
   * 전처리 및 후처리 렌더러 , 게터 동작 확인 및 묘화 실시

8. 후처리 테스트

9. 총합 테스트

   * 위의 모든 테스트를 연속으로 진행시킨다.