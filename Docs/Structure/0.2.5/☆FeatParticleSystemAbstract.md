# 파티클 시스템 구현

> 2018-08-02 문서 작성

## 문서

> 언리얼쪽을 참고해보자.

파티클 `Particle` 은 `Point sprite` 라고도 하며, 메쉬가 아니라 점에 텍스쳐를 입혀서 빌보딩 등으로 만드는 시스템이다. 메쉬를 사용해서 거기에 쉐이딩을 입혀 파티클과 비슷하지만 좀 더 사실적인 효과를 구현할 수도 있지만, 파티클의 경우에는 가장 기본적이지만 아주 간편하게 효과를 구현할 수 있다는 점, 그리고 성능을 보다 덜 잡아먹는다는 점에서 우수하다.

![EmitterCallout.png](https://docs.unrealengine.com/portals/0/images/Engine/Rendering/ParticleSystems/Cascade/EmitterCallout.png) 

## 제안 & 구현 사항

1. 파티클을 표현할 텍스쳐가 필요하다. 또한 텍스쳐를 출력할 쉐이더도 필요하다.
2. 한 입자를 출력하는데 필요한 시간, 혹은 시간 당 출력 양이 필요하다.
3. 각 입자의 생명주기가 필요하다.
4. 초기 사이즈, 생명 주기 당 사이즈, `ptcScale` 
   초기 속도, 생명 주기 당 속도, (내부)
   초기 틴트 컬러, 생명주기 당 틴트 컬러, `ptcTintColor`
   초기 스케일, 생명 주기 당 스케일, (내부)
   초기 회전, 생명 주기 당 회전, 로컬 포지션, 베이스가 되는 포지션 등... `ptcBasePosition` `ptcLocalPosition`
   초기 Alpha, 생명 주기 당 Alpha, `ptcAlpha`
5. 어떻게 파티클을 출력할 것인가 (방사, 등등..) 의 Spawn 역시 필요하다.
6. 각 입자의 생명 시간.

의 요소가 필요하다. 

1. 만약에 파티클마다 오브젝트 형태로 힙을 할당하게 된다면, 오브젝트 풀은 필수로 필요하다. 메모리는 많이 잡아먹을 지 언정 구현은 쉽다.
2. 또는, `OpenGL` 의 인스턴싱을 활용해서 속성 등을 `uniform` 배열과 현재 살아있는 파티클의 수를 쉐이더로 보내서 렌더링하게 한다. 이 방법은 오브젝트 풀이 필요 없지만, 구현이 쓸데없이 복잡하다.

#### 그래서?

일단 쉬운 방법으로 구현을 하고, 성능이 마땅하지 않을 때만 2의 방법을 고려해본다. 그런데 딱히 성능 차이가 있지는 않을 것 같다...

* 렌더러는 한 효과 당 하나만 바인딩한다. 각 파티클 오브젝트는 부모쪽의 (이미터) 렌더러를 가져와서 쓴다. 
* 파티클은 `CCObject` 이... 지 않다. 파티클은 `CComponent` 이며 파티클 안에 `Emitter` 와 `Renderer` 등의 부수 컴포넌트가 존재한다. 왜 `CCobject`가 아니냐면, `CCObject` 는 `Update()` 가 될 수도 있다.
* `CParticleRenderer` 는 `Emitter` 을 생성해서 반환하는 것, `Emitter` 의 위에서 말한 속성, 텍스쳐 등등을 변경하는 것이 가능하도록 API 을 제공한다.
* 파티클 컴포넌트 내부의 각 `Emitter` 는 오브젝트 풀을 가지며, 실제 렌더링을 할 수 있도록 한다.
* 만약 파티클을 담는 오브젝트가 지워졌을 경우에는, 소멸된 오브젝트의 파이널 포지션을 가진 채 임시 파티클 오브젝트 리스트에 들어가, 애니메이션이 다 끝날 때까지 기다린 후 소멸시킨다.
* 파티클의 렌더링은 마지막에 이루어지며, `Depth test` 등을 무시하고 `Blend` 을 항상 킨다. 주체는 파티클 컴포넌트이며 파티클 컴포넌트는 `pfRender()` 와 같은 함수에서 각 이미터에 `pfRender()` 와 같은 실질 렌더 함수를 돌려서 렌더링을 하도록 한다.
* 애니메이션이 끝난 각 오브젝트는 소멸하지 않고 Deactivate 되서 풀의 마지막에 보관된다.

#### 또한?

* 만약에 오브젝트 삭제되서 `Renderer` 가 이동되는 게 아니라, 오브젝트는 살아있지만 `Emitter` 가 삭제가 되버리면 어떻게 되는가? 도중에 렌더링을 끊어야 하는가? 아니면 `Emitter` 의 마지막 파티클이 끝날 때 까지 다른 곳에 보관해 뒀다가 `IsSleep` 이 True 이면 죽여야 하는가?

#### 테스트 구현하기

1. `ParticleTest` 라는 오브젝트에서 원형 텍스쳐가 빨간색에서 주황색, 그리고 노랑색으로 위로 점차 가속하면서 올라가는 것을 구현한다. 생명주기는 1.25초. 원형 텍스쳐는 Atlas 에서 가져올 수 있어야 한다. Atlas 에서 가져오는 텍스쳐는 `opSystem` 의 1번 텍스쳐이다.
   1. 우선 `ParticleSpawner` `ParticleEmitter` `ParticleRenderer` 3 콤보로 현재 `ParticleTest` 의 위치에 포인트 스프라이트로 하나 띄운다. 포인트 스프라이트로 어떻게 되는지만 한번 보자.

## 결과

#### 2018-08-03 PM 11:55

우선 가장 기본이 되는 `_internal::CParticleEmitter` 와 `CParticleRenderer` 의 뼈대를 만들었다. `Module` 의 구조를 생각해본 건데, `Emitter` 는 `Module` 을 컴포지션으로 가지고 있으며 이미터에서 지원하는 모듈이 없다면, 일반 Emitter 의 포인터 혹은 레퍼런스를 가져와서 사용한다.

또한 그리고 `Emitter` 에서 생성이 되는 각각의 파티클은, 사이즈, 생명 시간, 속도, 파티클 정책, 컬러, 스케일, 회전 각 및 현재 파이클 포지션 및 방향 등의 요소를 각각 가지고 있다. 이 파티클 오브젝트는 `Object pool` 에 적재되어 최대 생성량 * 최대 생명주기 시간 만큼의 요소를 미리 만든다.

그 후에 맨 마지막부터 차례차례로 `Activate` 해서 파티클을 렌더링할 수 있도록 한다. 오브젝트 풀은 업데이트 마다 

#### 2018-08-05 PM 07:14

`ParticleEmitter` 의 렌더러가 될 `ParticleRenderer` 을 만들었는데 이 렌더러는 쉐이더 고정, VAO 고정이 된다. 쉐이더는 `opParticle` 라고 하는 `v0.2.0` 의 빌트인 쉐이더를 쓸 것이며, VAO 에 바인딩할 모델은 빌트인의 1개의 빈 정점 $$ (x, y, z) $$ 만을 가진 클래스를 쓴다. 

그래서 클래스를 만들고 바인딩한 다음에 이를 `InternalParticleRenderer` 에 `VAO` 로서 적용하도록 했다. 

#### 2018-08-05 PM 08:17 

렌더링 과정?

1. Update() 시퀀스에서 `ParticleSpawner` 에서 각 `Emitter` 의 `Update()` 을 호출한다.
   그러면 `Emitter` 는 자기가 가지고 있는 모듈들의 수치를 업데이트하고, (그러면 각 풀에서 렌더시에 인자를 갱신할 때 `Emitter` 에서 가져옴)
   그리고 `Emitter` 을 렌더 시퀀스에 바인딩함. `Emitter` 하나당 `Renderer` 하나다.
2. 왜 `Renderer` 가 아니라 `Emitter` 을 시퀀스에 바인딩하냐면, `Emitter` 가 오브젝트 풀을 가지고 있고, 오브젝트 각각마다 다 다른 개별의 유니폼 변수 값 특성을 가지기 때문에 이를 한 Shader 에 개개별로 적용을 시켜야 한다. 따라서 `Renderer` 을 쓰게 되면 `Emitter` 에서 풀을 가져와야 하는 간접 비용이 생기기 때문에 `Emitter` 을 사용한다.
3. `Emitter` 을 사용하고 나서, 어느 다른 `Renderer` 처럼 **지금은** 리스트를 해제한다. 렌더링을 바인딩할 곳은 `manager::object` 이다.

#### 2018-08-05 PM 10:55

`Emitter` 마다 공통적인 특성들은 `Emitter` 에 저장하게 한다. 이제 해당 파티클의 입자 오브젝트를 구현해야 한다.

#### 2018-08-06 AM 12:41

1. 우선 Spawn 을 구현한다. `Spawn` 모듈이 구현되면, 한 루프의 주기를 정할 수 있고, 한 루프의 주기 당 몇 개가 스폰이 될 것인지, 또한 루프가 되풀이되느냐 마느냐도 정할 수 있다. 그러면 `Spawn` 모듈은 `Update()` 를 사용해서 시간을 재고 체크해서, `Emitter` 쪽의 입자 오브젝트 풀을 관리한다.
   * 만약 `Spawn` 모듈이 루프하지 않고 끝나면, 해당 `Spawn` 은 죽거나 비활성화된다.
   * `Spawn` 모듈은 기본으로 들어가 있다.
2. 그리고 각 모듈들은 해당 파티클이 실행되기 전까지 미리 세팅이 되어 있어야 한다. 도중에 설정을 바꾸는 것은 불가능하다. (미구현)

#### 2018-08-07 PM 12:55

1. 생명주기 모듈을 구현한다.