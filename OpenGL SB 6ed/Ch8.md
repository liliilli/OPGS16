# Chapter 8, Chapter 9

## Chatper 8 프리미티브 프로세싱

* 버텍스 쉐이더 이후에 처리되는 스테이지이다. **프리미티브 프로세싱 스테이지**라고 한다.

* 테셀레이션 고정 스테이지와, 테셀레이션 컨트롤(**TCS**), 테셀레이션 평가 스테이지(**TES**)로 구성된다.

* **Patch** 라는 큰 프리미티브를, 작고 많은 프리미티브로 쪼개는 작업이다. 즉, 적은 폴리곤에 지오메트리 디테일을 추가한다.

* **TCS** 는 다음을 생성해야 한다.

  1. 패치당 **내부 및 외부 테셀레이션 인자**
  2. 각 출력 제어점에 대한 **위치 및 기타 속성**
  3. 패치당 **사용자 정의 베어링**

  * 테셀레이션 인자는 테셀레이션 엔진으로 보내져서 어떻게 패치를 더 작은 프리미티브로 쪼갤 지 결정한다. 또한 TCS 의 출력은 이전과는 다른 새로운 Patch 이다.

* 만약 일부 데이터가 **Patch 단위**로 사용될 것이라면, 따로 표시하는 것이 좋다.

* 고정 함수 테셀레이션에 **테셀레이션 인자** `gl_TessLevelOuter[]` 와 `gl_TessLevelInner[]` 배열에 값이 들어간채로, 그리고 **Mode** 가 입력되면, 새로운 버텍스의 세트를 생성한다.

  * 테셀레이션 Mode 는, **TES** 의 레이아웃 선언을 사용해서 지정한다.

* **TES** 의 output 은 **NDC** 를 따른다. 

![TCS.jpg; 312 x 280 (@100%)](https://www.opengl.org/discussion_boards/attachment.php?attachmentid=1410&d=1409389801)

### 테셀레이션 프리미티브 모드

* 태셀레이션 모드는 OpenGL 이 Patch 을 래스터라이제이션으로 전달하기 전에 어떻게 여러 프리미티브로 쪼개지는지 결정한다. 쪼개질 **프리미티브의 모드**는 `quads` `triangles` `isolines` 중 하나로만 가능하다. 대개 보통은 선형 보간을 이용해서 정점을 만든다.
  * 프리미티브 모드는 생성될 프리미티브의 형태를 제어한다. 또한 인자가 어떻게 해석될지도 결정한다.
* `quads` 을 설정하면 테셀레이션 엔진은 기본 도형으로 사각형을 만들고, 이를 다시 삼각형들로 쪼갠다.
  * 사각형은, Outer 테셀레이션 레벨 인자가 4개, Inner 가 2개 존재한다. Outer 는 사각형 바깥의 테셀레이션 레벨을 결정하며, Inner 은 그 내부 `u` 와 `v` 테셀레이션 레벨을 결정한다.
* `triangles` 은 삼각형을 만든다.
  * Outer 가 3개, Inner 가 하나 존재한다. 버텍스를 만들 때, 각 정점은 대개 `TessCoord.xyz` 을 이용한 **중심좌표계**를 이용해 정점을 만든다. (선형 보간된 값이 된다)
* `isolines` 는 선으로 이루어진 등고선 형태를 만든다.
  * Outer 만 `u` `v` 2개 존재한다.


![img](Images/Ch8/triangle.png)

![img](Images/Ch8/contour.png)

* 테셀레이션이 비활성화일 경우에는, 보낸 정점의 순서에 따라서 Winding order 가 자동으로 결정된다. 하지만 활성화되었을 때는 **CW 혹은 CCW** 로 사용자 선택이 가능하다. 왜냐면 테셀레이션 단계에서 정점의 모든 연결 정보가 생성되기 때문이다.

  * TES 에서 다음과 같이 Winding order 가 설정 가능하다.

    ``` c++
    layout (cw) in;
    layout (ccw) in;
    ```

    기본 감기 순서는 반시계이며, `triangles` 에서만 적용될 수 있다.

### TS 간 쉐이더 전달

* TCS 가 수행되기 전에, 입력된 정점은 입력 제어점을 나타낸다. VS 는 그 제어점에 대해서 한번만 수행되며, TCS 가 실행될 때는 `glPatchParameteri(GL_PATCH_VERTICES,n)` 에 설정된 값에 의해 그룹으로 입력된다.
  * 이 때 각 정점에서 `out` 으로 넘겨받는 변수, 구조체 변수 등 역시 n 크기 만큼의 **배열**로 넘겨받는다.
* 테셀레이션의 출력 역시 **배열**이다. 하지만 `GL_MAX_PATCH_VERTICES` 라는 상수값에 의해 알아서 결정된다. 
* TES 의 입력 역시 배열이고, 이 때는 전 스테이지에서 생성된 정점에 대해 한번씩 수행된다. 이 역시 다른 버텍스에 접근이 가능하다.
* **TCS 의 역할**은, TES 에서 쓸 패치의 입력값을 계산하고, 테셀레이션에서 사용할 레벨의 값을 설정하는 역할을 맡는다. 
* TCS 없이, `glPatchParamterfv(GLenum pname, const GL_float* values)` 만으로 TES 에 레벨을 전달할 수도 있다.
  * 다만 GL_PATCH_DEFAULT_INNER_LEVEL 일 때는 2개의 부동소수점이 필요하다.
    GL_PATH_DEFAULT_OUTER_LEVEL 에서는 4개가 필요하다.
* TCS 는 호출이 **완전 병렬**로 이루어진다는 것을 전제로 했기 때문에, **barrier()** 을 사용해서 모든 스레드의 TCS 호출이 해당 지점에서 멈추게 한 뒤 동기화를 시도할 수 있다. 
  (배리어 동기화)

#### 지형 테셀레이션

* 예제의 지형 테셀레이션은 `glDrawArraysInstanced` 을 이용해서 64 x 64 크기의 그리드를 그려낼려고 하고 있다. 각 그리드의 크기는 1 x 1 이다.
* Vertex Shader 에서는 각 인스턴스 (`gl_InstanceID`) 이 가지고 있는 각 정점을 4개가 (`gl_VertexID`) 있다. 
  * 각 그리드의 넘버를 좌표로 가진 Offset 으로, 각 정점의 Texture Coordinate 을 지정한다.
  * 가장 맨 처음 인덱스를 가지는 인스턴스는 $ (-32, 0, -32) $ 에 렌더링된다.
* TCS 에서는 버텍스를 4개 받아서 (`glPatchParamateri` 로 패치 지정이 필요하다) NDC 에서서의 클리핑을 행한다.
  * 또한, 각 정점의 스크린 상에서의 거리 (NDC 에서의 거리) 에 따라, **동적으로 레벨을 변경한다 (Dynamic LOD)** . 왜냐면 최적화를 위해서다.
  * 그리고 텍셀 역시 TES 로 넘기는데, 이 때는 Patch 단위이기 때문에 `gl_InvocationID`을 이용한다.
* TES 에서 Height Map (임의로 붙인 이름) 을 사용해서, 만들어진 정점 마다의 `y` (Height) 값을 정한다. 이 때 높이 인자에 의해 최대 높이가 달라질 수 있다. 또한 선형보간으로 만들어진 정점은 MVP 매트릭스를 이용해 NDC 로 줄인다.
  * 텍셀은 FS 에서 쓰기 위해서 긴다.
* Fragment Shader 에서는 그냥 텍셀 위치와 텍스쳐를 사용해서 색을 뽑아낸다.

그러면 잘 되더라.

#### 3차 베지어 곡선을 이용한 평면 물결

* ​

### 지오메트리 쉐이더

* 테셀레이션과는 다르게, 지오메트리는 완전히 **프로그래밍으로 파이프라인의 데이터 양을 변경**하는 것이 가능하다. (늘였다가, 줄였다가) 또한, 전체 프리미티브를 한 프리미티브당 한 번에 처리한다.

  * 테셀레이션 쉐이더들은, 들어온 패치들을 분리된 프리미티브로 만들 수 없다. 하지만 지오메트리는 가능하다. 프래그먼트 쉐이더같은 경우는 `discard` 로 가능하지만 새로운 프래그먼트를 생성할 수는 없다.
  * 지오메트리 쉐이더는 **프리미티브를 생성, 삭제** 가 가능하며, **프리미티브의 타입**변경이 되며, **정점 자체에 접근이 가능하다**.
  * 지오메트리 쉐이더가 없으면, 마지막 스테이지의 버텍스들은 렌더링되는 프리미티브에 걸쳐서 **보간이 되어 FS에 넘겨진다**. 만약 지오메트리 쉐이더가 있으면 이 쉐이더 뒤에 프리미티브의 정점이 보간이 되어 넘겨진다.

* 지오메트리 쉐이더는 입력 프리미티브 (`triangles` and so on) 의 모든 버텍스를 접근할 수 있기 때문에, **입력은 배열**로 선언된다. (명시적으로 선언할 필요는 없다)

* 쉐이더는 루프를 포함하는 경우가 대다수이다. 이 때 `in` 의 모든 요소를 살피기 위해 `gl_in.length()` 으로 크기를 가져올 수 있다.

* GS 을 포함한 쉐이더를 이용해서 드로잉 커맨드를 쓸 때에는 **GS 의 입력 프리미티브 모드** 와 같아야 한다. 다만, 테셀레이션이 활성화 되었을 때는 항상 **GL_PATCHES** 여야 한다.

* GS 의 `gl_in[]` 의 정의는 다음과 같다.

  ``` c++
  in gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
  } gl_in[];
  ```

  * 또한, 이전 스테이지에서 넘겨받은 일반 구조체 역시 배열로 선언된다 (해야한다!) 따라서 변수를 넘겨 받을거라면 구조체로 하는 게 낫다.

* 지오메트리 쉐이더에 허용되는 **출력 프리미티브 타입**은 `points` , `line_strip`, `triangle_strip` 이다. (연결되야 하기 때문에 _strip 과 같은 어미가 붙은건가?)

  * `max_vertices` 을 이용해서 해당 프리미티브로 출력할 정점들의 최대 출력 수를 지정할 수 있다. (되도록이면 작은 값을 설정하는 것이 좋다!)
  * 또한 `gl_Position` 은 NDC (클립 영역) 이어야 한다. 

* `EmitVertex()` 는 값들을 모든 출력 변수에 저장하고 (임의로 `out` 변수로 지정한 것까지 다!) 새로운 버텍스를 위한 공간을 만든다. 따라서 모든 버텍스에 대해서 단일 색상을 넘기고 싶다면 일일히 지정해줘야 한다.

  * `EndPrimitive()` 을 쓸 때, 프리미티브를 생성하기 위한 충분한 정점을 생성하지 못했다면 기존의 버텍스 역시 없어져버린다.

* 테셀레이션이 많이 필요할 때 지오메트리를 사용하는 것은 성능 상에서 최적이 아니다. 간단한 경우에만 지오메트리를 쓰는 것이 컴퓨터에게 좋다.

### 뷰포트 변환

* 윈도우에 그려질 스크린 영역을 지정하려면, `glViewport()` 와 `glDepthRange()` 가 필요하다. 하지만 뷰포트를 이동시켜서 하나의 큰 프레임 버퍼를 갖는 여러 가상 윈도우에 그리는 것도 가능하다. 또한 **여러 뷰포트**를 동시에도 사용할 수 있다.

* `glViewportIndexedf(index, x, y, w, h)` **혹은** `glViewportIndexedfv(index, GLfloat* vector)` 로 뷰포트 인덱스에 크기 설정이 가능하다. 기존 Viewport() 함수는 모든 인덱스의 뷰포트를 동일한 크기로 설정하는 것이다.

  * 뷰포트는 최소 16개 이상을 지원하도록 명시되어 있다.
  * `glViewportArrayv(start, count, GLfloat* vector)` 로 해당 인덱스부터 몇 개 까지의 뷰포트에 배열의 정보를 이용해 한꺼번에 설정할 수도 있다.

* 특정 뷰포트에 렌더링하기 위해서는 GS 의 `gl_ViewportIndex` 을 사용해서 넘겨줘야 한다. 이 때 `in` 에서 `invocations` 라는, 동일한 프리미티브를 몇 번이고 재호출할 수 있는 인자를 사용해서 써도 좋다.

  ``` c++
  layout (triangles, invocations = 4) in;
  // ...
  gl_ViewportIndex = gl_InvocationID; // 0, 1, 2, 3?
  ```

  * 이렇게 하면 각각 클리핑이 되면서 지정된 영역에 적절하게 보이게 된다.

---

## Chapter 9 FS, FB

* 프래그먼트는 색상을 결정하는 파이프라인 스테이지이다. **프레임버퍼**에 합성을 위해서 보내진다.

* 프래그먼트는 프래그먼트 단위로 수행되며, 필요한 입력 변수의 값들은 **래스터라이제이션 단계에서 수행되는 보간**에 의해 자동 생성된다. 따라서 `in` 등에 `flat` 을 넣지 않고, 값이 정수가 아닌 이상 모든 프래그먼트에 대해 자동으로 보간이 된다.

  * 만약에 명시적으로 값을 보간을 하겠다고 하면, `smooth` 을 넣으면 된다. 또한 프래그먼트에 `flat`, `smooth` 을 적을 때 프래그먼트 이전에 설정한 마지막 스테이지에서 `out` 되는 변수에 명시적으로 `flat` 을 적어야 한다. 

    ``` c++
    flat in vec4 foo;
    flat in INPUT_BLOCK {
      vec4 foo;
      smooth mag3 baz;
    };
    ```

  * 변수가 `flat` 일 때 프래그먼트가 취할 값은 **프리미티브의 첫 또는 마지막 정점**의 값을 따른다. 이 정점을 **Provoke Vertex** 라고 하며 다음 함수를 통해서 결정할 수 있다.
    ` glProvokingVertex(GLenum provokeMode)` 로, GL_FIRST_VERTEX_CONVENTION 혹은 GL_LAST_ 을 사용해 첫번째나 마지막 버텍스의 값을 평평한 입력의 값으로 취할 수 있다. 기본은 GL_LAST 이다.

### Perspective Correct Interpolation

* 내용 이해가 안간다. 나중에 봐야겠다.

### 프래그먼트별 테스트

* OpenGL 은 프래그먼트 쉐이더에 대해 많은 다른 테스트를 수행해서 프레임버퍼에 어떻게 쓸지를 판단할 수 있다.
  * Scissor test
  * Stencil test
  * Depth test 가 있다.

#### Scissor Test

* 가위 사각형은 **화면 스크린 좌표를 지정하는 임의의 사각형**을 통해, **특정 영역만 렌더링할 수 있도록** 한다. 뷰포트를 이용해서 지오메트리를 세팅해줘야 했던 것과는 다르게, 레스터라이저 이후 처리의 일부이다.
  * 개별 프래그먼트를 각 사각형에 대해서 들어오는지 아닌지를 테스트한다.
* `glScissorIndexed()` 혹은 `glScissorIndexedv()` 을 호출해서 스크린 공간에서 가위질 할 공간을 정한다. 그리고 `glEnable(GL_SCISSOR_TEST)` 을 사용해서 테스트할 수 있다.
* 가위 테스트를 할 때 `glClear()` 은 첫번째 가위 테스트의 정보를 지우기 때문에 이를 염두해야한다? (번역이 뭔가 이상해서 잘 모르겠다.)

#### Stencil Test

* 프레임버퍼의 픽셀 포맷이 스텐실 버퍼를 포함하면, **그리는 내용을 마스킹**해서 특정 영역에만 오브젝트를 렌더링할 수 있도록 할 수 있다.
* 스텐실 버퍼의 각 값은 8비트 (1byte) 의 값을 담을 수 있다. 
* 드로잉 명령은 스텐실 버퍼에 직접 영향을 준다. 그리고 스텐실 버퍼의 값은 그릴려는 픽셀들에 직접 영향을 준다. 이렇게 상호 작용 방식이 있기 때문에 OpenGL 은 두 명령을 제공하고 있다.
  * `glStencilFuncSeparate(face, func, ref, mask)` 는 스텐실 테스트가 실패해서 그리지 못하는가, 아니면 성공해서 그려지는가를 정할 수 있다. face 는 GL_FRONT, GL_BACK, GL_FRONT_AND_BACK 으로 어떤 지오메트리가 다음 조건을 테스트하는지 알 수 있다.
  * `glStencilOpSeparate()` 는 어떤 지오메트리 타입에 테스트에 성공하거나 실패할 경우 스텐실 버퍼의 값을 어떻게 처리할지를 결정할 수 있다.
  * `glStencilMaskSeparate(face, bit_mask)` 을 통해서 각 지오메트리의 스텐실 버퍼의 8비트 값의 일정 부분만 활성화시킬 수 있다.

#### Depth Test

* 스텐실 연산이 완료되면 깊이 연산을 처리한다. (GL_DEPTH_TEST 가 활성화 되어 있을 때만) 만약 NDC 의 프래그먼트가 깊이 테스트를 통과하면 (GL_LESS) 해당 위치의 깊이 버퍼는 프래그먼트의 깊이 값 `z` 값으로 갱신된다. 
* 만약 GL_DEPTH_TEST 가 활성화 되어있다고 해도 `glDepthMask(GLbool)` 을 써서 깊이 테스트를 할 때 버퍼를 갱신 가능 유무를 변경할 수 있다.
* NDC 에서 $ [0, 1] $ 사이의 깊이 값을 가진 것만 화면에 렌더링되기 때문에, 앞쪽으로 짤리는 것을 막기 위해서 **깊이 고정** 을 쓸 수도 있다.
  * `glEnable(GL_DEPTH_CLAMP)` 을 사용해서 $ [0, 1] $ 에서 벗어나는 프래그먼트를 $ [0, 1] $ 로 CLAMP 할 수 있다. 이러면 의도치 않게 오브젝트가 잘려나가는 문제를 해결할 수 있다. (부수효과 역시 따른다)

#### 색상 마스킹

* 프래그먼트 쉐이더에서 실행되는 테스트는 컬러 테스트, 스텐실, 버퍼 테스트가 있다. 여기서 컬러 테스트에 사용되는 색상 버퍼를 **인덱스를 지정해서**, **RGB별마다 마스킹 여부를 지정할 수 있다**
  * `glColorMaski(index, R, G, B, A)` 로 가능하다. index 는 컬러 버퍼의 인덱스를 지정한다. 사용자 정의 프레임버퍼의 경우에는 여러 개의 컬러 버퍼가 지정 가능하다.
* 한 프레임 버퍼 오브젝트에는 최대 8개의 텍스쳐를 붙일 수 있다.

### 레이어 렌더링

> 레이어 렌더링이랑 FBO 완전성은 나중에 돌리자... 귀찮다

### 안티에일리어싱

* **Aliasing**
  무수한 데이터를 적은 수 혹은 한정된 수의 데이터로 언더 샘플링을 할 때 발생하는 현상이다. 데이터의 어느 시점에서 불연속성이 나타나 끊기거나 한다.

  * *Nyquist rate*
    원본의 내용을 **대부분** 유지하기 위해서는 신호의 가장 높은 주파수보다 두 배 더 높은 주파수로 샘플링을 해야한다는 법칙.

* AA 을 적용하는 첫번째 방법은 **그릴 때 프리미티브를 필터링** 하는 방법이다. 프리미티브가 차지하는 픽셀의 양을 계산해서 각 프래그먼트의 알파값을 만드는 방식이다. 이 알파값은 쉐이더에서 생성한 프래그먼트의 알파값에 곱해져 GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA 을 적용한 블렌딩과 같은 효과를 낸다.

  * ``` glsl
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_LINE_SMOOTH);
    ```

    로 프리미티브 필터링 및 보간 및 블렌딩을 활성화할 수 있다.

  * 하지만 이 방법은 한계가 있다. GL_POLYGON 을 사용해도 완벽하게 AA가 되지 않는다. 이유는 각 프래그먼트를 픽셀의 면적에 비례해서 알파값을 구해, 이것을 블렌딩하기 때문이다. 따라서 완벽하게 AA 을 구현하기 위해서는 **샘플 개수를 늘려서** 해결해야 한다.

* **MSAA** 는 픽셀 내에 여러 개의 샘플 제어점을 두고, 아무 프래그먼트라도 걸리면 쉐이더를 실행해서 제어점 값을 갱신하여 (n 개 만큼) 이를 블렌딩하는 방식이다.

### 부동소수점 프레임버퍼

* OpenGL 파이프라인은 내부적으로 부동소수점을 사용하지만, 텍스쳐나 Framebuffer Attachment 같은 경우에는 **고정 소수점**을 사용한다. 고정 소수점은, IEEE754 을 따르지 않고 일련의 비트를 이용해 **정해진 자리의 소수점 수**를 표현하는 방식이다.
* **Framebuffer** 는 부동소수점 포맷의 Attachment 을 사용할 수 있다. 또한 텍스쳐가 고정 소수점을 사용하지 않고 **부동 소수점을 사용할 수 있도록**해서 프레임버퍼로 렌더링을 하게 할 수 있다.
  * 또한 부동소수점 데이터가 고정 포맷에 어떻게 사상되는지도 확인할 수 있다. 이를 **HDR(High dynamic range)** 라고 한다.
* 텍스쳐가 부동소수점 포맷을 사용하기 위해서는 다음과 같이 텍스쳐를 바인딩해서 설정할 때 내부 포맷을 부동소수점으로 쓰게 하면 된다.
  * `glTexStorage2D(format, mipmap, GL_RGBA16F or GL_RGBA32F, width, height)`
    을 쓰면 된다. `glTexStroage1D` 등에도 쓸 수 있다.
  * `GL_16F 32F` 포맷은 RGBA, RGB, RG, R 등 여러가지가 존재하기 때문에 골라 쓰면 된다. 32비트 워드를 구성하는 `GL_R11F_G11F_B10F` 도 존재한다. 물론 이 포맷을 쓸 때는 저장할 Data 역시 같은 포맷이 되도록 해야한다. 그렇지 않으면 비정의 행동을 일으킬 것이다.
  * 또는 `GL_DEPTH_COMPONENT32` 와 같은 포맷으로 저장할 수도 있다.
* **HDR** 을 사용한 게임 내 기법에는 **Bloom**, **렌즈 플레어**, 빛 반사, 굴절, 석양 광선, 먼지 구름 등이 사용된다. 위 기법들에는 항상 부동소수점 버퍼가 사용된다.
  * 부동소수점 버퍼에 대한 HDR 렌더링은, **밝은 부분을 밝게** 하고 **어두운 부분은 매우 어둡게** 하면서도 양 디테일을 함께 볼 수 있도록 한다.


### 포인트 스프라이트

* **Point sprite** 라는 용어는 보통 텍스쳐가 입혀진 점들을 말한다. OpenGL 에서는 각 점을 단일 정점으로 표시한다. 따라서 다른 프리미티브 타입같이 (GL_TRIANGLES 등) 텍스쳐 좌표를 이용해서 **보간이 불가능**하다.
  * 하지만 보간된 텍스쳐 좌표를 가져와서 사용할 수 있다. 이걸로 하나의 3D 점으로 2D 텍스쳐가 입혀진 이미지를 화면에 그릴 수 있게 된다.
* *포인트 스프라이트*의 가장 주요한 용도는 **Particle 시스템**이다. 포인트 스프라이트를 사용해서 대량의 파티클이 (빌보드인채로) 화면에서 움직이게 할 수도 있다. 이것들을 이용해서 애니메이션되는 불빛도 움직일 수 있다.
  * 만약 *Point Sprite* 을 사용하지 않고 효과를 만들려면 텍스쳐를 입힌 사각형 또는 삼각형을 아주 많이 많이 그려야 한다. 그러면 빌보드 효과를 내기 위해서 추가 연산이 필요해진다. 또한 모든 파티클들을 Orthographic Projection 으로 투영해야 한다. 여러모로 복잡해진다.