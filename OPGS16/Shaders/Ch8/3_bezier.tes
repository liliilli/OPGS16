#version 430 core

layout (quads) in;
uniform mat4 mv;
uniform mat4 projection;
const float epsilon = 0.001f;

out TES_OUT {
	vec3 N;
	vec2 texCoord;
} tes_out;

in TCS_OUT {
	vec2 texCoord;
} tes_in[];

vec4 quadratic_bezier(vec4 A, vec4 B, vec4 C, float t) {
	vec4 D = mix(A, B, t);
	vec4 E = mix(B, C, t);

	return mix(D, E, t);
}

vec4 cubic_bezier(vec4 A, vec4 B, vec4 C, vec4 D, float t) {
	vec4 E = mix(A, B, t);
	vec4 F = mix(B, C, t);
	vec4 G = mix(C, D, t);

	return quadratic_bezier(E, F, G, t);
}

vec4 evaluate_patch(vec2 at) {
	vec4 P[4]; // New values

	for (int i = 0; i < 4; ++i) {
		P[i] = cubic_bezier(gl_in[i + 0].gl_Position,
							gl_in[i + 4].gl_Position,
							gl_in[i + 8].gl_Position,
							gl_in[i +12].gl_Position,
							at.y);
	}

	return cubic_bezier(P[0], P[1], P[2], P[3], at.x);
}

vec4 evaluate_texCoord(vec2 at) {
	vec4 P[4];

	for (int i = 0; i < 4; ++i) {
		P[i] = cubic_bezier(vec4(tes_in[i + 0].texCoord, 0, 0),
							vec4(tes_in[i + 4].texCoord, 0, 0),
							vec4(tes_in[i + 8].texCoord, 0, 0),
							vec4(tes_in[i +12].texCoord, 0, 0),
							at.y);
	}

	return cubic_bezier(P[0], P[1], P[2], P[3], at.x);
}

void main() {
	vec4 p1 = evaluate_patch(gl_TessCoord.xy);
	vec4 p2 = evaluate_patch(gl_TessCoord.xy + vec2(0, epsilon));
	vec4 p3 = evaluate_patch(gl_TessCoord.xy + vec2(epsilon, 0));

	vec3 v1 = normalize((p2 - p1).xyz);
	vec3 v2 = normalize((p3 - p1).xyz);

	tes_out.N = cross(v1, v2);
	tes_out.texCoord = vec2(evaluate_texCoord(gl_TessCoord.xy));

	gl_Position = projection * p1;
}